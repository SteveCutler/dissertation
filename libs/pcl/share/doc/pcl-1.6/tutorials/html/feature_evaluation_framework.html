

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Benchmarking Feature Descriptor Algorithms</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="None" href="index.html" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul> 
      </ul>
    </div>

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="benchmarking-feature-descriptor-algorithms">
<span id="feature-evaluation-framework"></span><h1>Benchmarking Feature Descriptor Algorithms</h1>
<p>In this tutorial, we will go over how to use the FeatureEvaluationFramework class to benchmark various feature descriptor algorithms.
The benchmarking framework allows the testing of different kinds of feature descriptor algorithms, over a choice of independent variables,
ranging from input clouds, algorithm parameters, downsampling leaf size, and search threshold.</p>
<p>To ensure extensibility of the framework, the functionality is divided into multiple classes as follows:</p>
<img alt="_images/class_hierarchy.png" class="align-center" src="_images/class_hierarchy.png" />
</div>
<div class="section" id="using-the-featurecorrespondencetest-class">
<h1>Using The FeatureCorrespondenceTest Class</h1>
<p>The FeatureCorrespondenceTest class performs a single &#8220;feature correspondence test&#8221; as follows:</p>
<blockquote>
<div><ul class="simple">
<li>The FeatureCorrespondenceTest class takes two input clouds (source and target).</li>
<li>It will compute feature descriptors in each cloud using the specified algorithm and parameters.</li>
<li>Each feature in the source cloud will be matched to its corresponding feature in the target cloud based on a nearest neighbor search in the n-D feature space.</li>
<li>For each point, the system will compare the 3D position of the estimated corresponding target point to the previously established ground truth position.</li>
<li>If the two points are close together (as determined by a user specified threshold), then the correspondence is marked as a success. Otherwise, it is marked a failure.</li>
<li>The total number of successes and failures will be calculated and stored for further analysis.</li>
</ul>
</div></blockquote>
<p>The functions which perform common tasks are provided in the FeatureCorrespondenceTest class. Functions specific to the Feature Descriptor algorithm
(i.e. the actual computation of features) must be defined in a separate child class derived from FeatureCorrespondenceTest. For example, FPFHTest
is a child of FeatureCorrespondenceTest, and it implements functions for calculation of FPFH features on the input clouds (computeFeatures())
and for calculating correspondences between the clouds, in the n-D feature space (computeCorrespondences()).</p>
<p>As a result, we get a consistent interface to the FeatureCorrespondenceTest class which can be manipulated through the FeatureEvaluationFramework,
while at the same time providing means to add new feature algorithms to the testing framework whenever required.</p>
</div>
<div class="section" id="using-the-featureevaluationframework-class">
<h1>Using The FeatureEvaluationFramework Class</h1>
<p>The FeatureEvaluationFramework class encapsulates the actual benchmarking functionality. It has one template parameter, which should match the point_type
of the point clouds to be given as input to the framework.</p>
<p>To initialize the FeatureEvaluationFramework object, the following set of functions should be called:</p>
<blockquote>
<div><ul class="simple">
<li>setFeatureTest : Choose the Feature Descriptor algorithm to be tested</li>
<li>setInputClouds : Load source and target clouds from .pcd files</li>
<li>setGroundTruth : Load the ground truth transformation as 4x4 matrix, from a file</li>
<li>setThreshold : Either a single threshold value, or a threshold range, specified by lower bound, upper bound, and delta</li>
<li>setParameters : Specific to the Feature Descriptor algorithm, to be given as a &#8220;key1=value1, key2=value2, ...&#8221; string</li>
<li>setDownsampling : Choose whether to filter input clouds through VoxelGrid filter</li>
<li>setLeafSize : Set Voxelgrid leaf size for downsampling input clouds</li>
<li>setLogfile : Set logfile to store output of the test in CSV format</li>
<li>setVerbose : Choose whether to show step by step progress of the benchmarking on the console</li>
</ul>
</div></blockquote>
<p>After this, we are ready to perform the test. There are two possibilities:</p>
<blockquote>
<div><ul>
<li><p class="first">Single Test : Perform a single feature extraction and store the output statistics by calling runSingleTest().</p>
</li>
<li><dl class="first docutils">
<dt>Multiple Tests <span class="classifier-delimiter">:</span> <span class="classifier">Perform multiple tests with varying a single independent variable, and store the set of outputs in CSV format (in the logfile).</span></dt>
<dd><p class="first">The supported function calls are:</p>
<blockquote>
<div><ul class="simple">
<li>runMultipleFeatures() - Perform test with multiple feature descriptor algorithms</li>
<li>runMultipleClouds() - Run same feature evaluation on a (large) set of input clouds</li>
<li>runMultipleParameters() - Perform the feature evaluation with varying parameter values</li>
<li>runMultipleLeafSizes() - Vary the Voxelgrid leaf size for downsampling the input cloud before performing each evaluation</li>
</ul>
</div></blockquote>
<p class="last">The values for the independent variable are taken as input from a text file, which should be provided as an argument to this function.
For example, runMultipleLeafSizes(std::string filename) will read values for the Voxelgrid leaf size from each line of &#8220;filename&#8221;, and perform
a feature extraction for each leaf size, storing the set of results in the output logfile.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="supported-datasets-and-groundtruth-format">
<h1>Supported Datasets And Groundtruth Format</h1>
<p>The input clouds (source and target) are read from .pcd files. The point type of the clouds should match the template parameter used in FeatureEvaluationFramework,
i.e. to use PointXYZRGB clouds, create an object of type FeatureEvaluationFramework&lt;PointXYZRGB&gt; to perform the evaluation.</p>
<p>The ground truth is a (Vector3f, Quaternionf) pair corresponding to the rigid transformation mapping the source and target clouds.
Currently, the ground truth matrix is read from a file containing 7 values on one line,
where first three values are taken as a Vector3f and next four are taken as a Quaternionf.</p>
<p>The <a class="reference external" href="http://people.willowgarage.com/mdixon/benchmarks/conference_room.tar.bz2">conference room dataset</a> contains 350 point clouds (cloud_###.pcd) and corresponding 7-D pose of the camera (pose_###.txt).
We will be using clouds from this dataset to perform the benchmarking, however the framework can easily incorporate other datasets in the future.</p>
</div>
<div class="section" id="sample-evaluation-fpfhtest">
<h1>Sample Evaluation: FPFHTest</h1>
<p>Question: What radius of the FPFH feature is most effective on the conference room data set?</p>
<p>The following program runs the FPFHEstimation algorithm on given input cloud, and ground truth, for a given set of search radius values.</p>
</div>
<div class="section" id="compiling-and-executing-the-code">
<h1>Compiling And Executing The Code</h1>
<p>Add the following lines to your CMakeLists.txt file:</p>
<p>To execute, first create a text file containing the set of parameters (here, search radius) values on which you want to run the test. Call it &#8220;radius-values.txt&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">searchradius</span><span class="o">=</span><span class="mf">0.05</span>
<span class="n">searchradius</span><span class="o">=</span><span class="mf">0.07</span>
<span class="n">searchradius</span><span class="o">=</span><span class="mf">0.1</span>
<span class="n">searchradius</span><span class="o">=</span><span class="mf">0.15</span>
</pre></div>
</div>
<p>Also, you need an input point cloud (say cloud_000.pcd from the conference room dataset) and a file containing the ground truth (say pose_000.txt).
Assuming they are present in the same directory as the executable, execute the following command (otherwise provide relative path to those files):</p>
<div class="highlight-python"><pre>$ ./fpfh_radius cloud_000.pcd pose_000.txt radius-values.txt</pre>
</div>
<p>As each feature extraction test progresses, you should see output similar to this on the console:</p>
<div class="highlight-python"><pre>Set input clouds
Set ground truths
Set threshold
Perform downsampling
Set parameters
----------Test Details:----------
Feature Name:  FPFHTest
Input Dataset: cloud_000.pcd
Parameters:    searchradius=0.05
Leaf size:     0.01 0.01 0.01
---------------------------------

Computing features
FPFHTest: computing normals
FPFHTest: computing source features
FPFHTest: computing target features
Time taken: 4.66
Computing correspondences
Computing results
----------Test Results:----------
Source Size:   22420
Target Size:   24800
Time Taken For Feature Computations:
  Source:      1.93
  Target:      2.35
  Total:       4.66
Threshold -&gt; Successes
  0.1 -&gt; 86
  0.2 -&gt; 14276
  0.3 -&gt; 16234
  0.4 -&gt; 17692
  0.5 -&gt; 18615
  0.6 -&gt; 19189
  0.7 -&gt; 19701
  0.8 -&gt; 20116
  0.9 -&gt; 21115
---------------------------------</pre>
</div>
</div>
<div class="section" id="making-sense-of-the-results">
<h1>Making Sense Of The Results</h1>
<p>Opening the output logfile &#8220;fpfh-radius-variation.txt&#8221; you should see something like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">searchradius</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span><span class="mf">1.95</span><span class="p">,</span><span class="mf">2.39</span><span class="p">,</span><span class="mf">4.72</span>
<span class="mf">0.1</span><span class="p">,</span><span class="mi">85</span>
<span class="mf">0.2</span><span class="p">,</span><span class="mi">14326</span>
<span class="mf">0.3</span><span class="p">,</span><span class="mi">16280</span>
<span class="mf">0.4</span><span class="p">,</span><span class="mi">17753</span>
<span class="mf">0.5</span><span class="p">,</span><span class="mi">18674</span>
<span class="mf">0.6</span><span class="p">,</span><span class="mi">19248</span>
<span class="mf">0.7</span><span class="p">,</span><span class="mi">19754</span>
<span class="mf">0.8</span><span class="p">,</span><span class="mi">20160</span>
<span class="mf">0.9</span><span class="p">,</span><span class="mi">21155</span>

<span class="n">searchradius</span><span class="o">=</span><span class="mf">0.07</span><span class="p">,</span><span class="mf">3.45</span><span class="p">,</span><span class="mf">4.25</span><span class="p">,</span><span class="mf">8.26</span>
<span class="mf">0.1</span><span class="p">,</span><span class="mi">76</span>
<span class="mf">0.2</span><span class="p">,</span><span class="mi">16883</span>
<span class="mf">0.3</span><span class="p">,</span><span class="mi">18256</span>
<span class="mf">0.4</span><span class="p">,</span><span class="mi">19338</span>
<span class="mf">0.5</span><span class="p">,</span><span class="mi">20033</span>
<span class="mf">0.6</span><span class="p">,</span><span class="mi">20474</span>
<span class="mf">0.7</span><span class="p">,</span><span class="mi">20829</span>
<span class="mf">0.8</span><span class="p">,</span><span class="mi">21148</span>
<span class="mf">0.9</span><span class="p">,</span><span class="mi">21661</span>

<span class="n">searchradius</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">6.42</span><span class="p">,</span><span class="mf">8.03</span><span class="p">,</span><span class="mf">15.36</span>
<span class="mf">0.1</span><span class="p">,</span><span class="mi">85</span>
<span class="mf">0.2</span><span class="p">,</span><span class="mi">18572</span>
<span class="mf">0.3</span><span class="p">,</span><span class="mi">19439</span>
<span class="mf">0.4</span><span class="p">,</span><span class="mi">20222</span>
<span class="mf">0.5</span><span class="p">,</span><span class="mi">20695</span>
<span class="mf">0.6</span><span class="p">,</span><span class="mi">20899</span>
<span class="mf">0.7</span><span class="p">,</span><span class="mi">21181</span>
<span class="mf">0.8</span><span class="p">,</span><span class="mi">21442</span>
<span class="mf">0.9</span><span class="p">,</span><span class="mi">21809</span>

<span class="n">searchradius</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span><span class="mf">12.78</span><span class="p">,</span><span class="mf">17.08</span><span class="p">,</span><span class="mf">31.57</span>
<span class="mf">0.1</span><span class="p">,</span><span class="mi">69</span>
<span class="mf">0.2</span><span class="p">,</span><span class="mi">20264</span>
<span class="mf">0.3</span><span class="p">,</span><span class="mi">21077</span>
<span class="mf">0.4</span><span class="p">,</span><span class="mi">21563</span>
<span class="mf">0.5</span><span class="p">,</span><span class="mi">21741</span>
<span class="mf">0.6</span><span class="p">,</span><span class="mi">21786</span>
<span class="mf">0.7</span><span class="p">,</span><span class="mi">21836</span>
<span class="mf">0.8</span><span class="p">,</span><span class="mi">21912</span>
<span class="mf">0.9</span><span class="p">,</span><span class="mi">22228</span>
</pre></div>
</div>
<p>Lets analyse what does this file mean.</p>
<p>Each block of data corresponds to a particular test run. The first line specifies the algorithm parameters, time taken for source feature computation, time taken for target feature computation, and total time taken for feature computation</p>
<p>Next we have a set of values, each of which is a (threshold, successes) pair. For each threshold value, the number of successes denote the number of points in the source cloud whose corresponding point in the target cloud lie at a distance less than that threshold from the ground truth position of that point, in 3D space.
The correspondences are calculated by doing nearest neighbour search between the source and target feature points in n-D feature space.</p>
<p>We would expect more successful correspondences, at lower threshold values, to be a measure of the quality of the feature extraction algorithm.
Here, at a particular threshold value of 0.2, as we increase the search radius, the successes are increasing monotonically, and so is the time taken for the feature computation.</p>
</div>
<div class="section" id="adding-new-features-to-the-framework">
<h1>Adding New Features To The Framework</h1>
<p>Adding new feature algorithms to the testing framework is very straightforward: one needs to derive a new child from the FeatureCorrespondenceTest base
class, and implement the following member functions:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>setParameters (ParameterList params)</dt>
<dd><p class="first last">Here ParameterList is a map&lt;string, string&gt; which contains (key,value) pairs of the different parameters passed to the algorithm.
This function should parse the provided ParameterList and store the relevant parameter values, to be used in feature computation.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>computeFeatures (double&amp; time_source, double&amp; time_target)</dt>
<dd><p class="first last">This function should perform the actual computation of source and target features, and the implementation details will vary according to the
algorithm in question. The arguments time_source, and time_target should be filled with the time taken for source and target feature computation
respectively.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>computeFeatures ()</dt>
<dd><p class="first last">Same as above, except runtime statistics are not to be measured.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>computeCorrespondences ()</dt>
<dd><p class="first last">For each source point, compute its nearest neighbour from the target cloud, in the n-D feature space, and store the correspondences in
MapSourceToTargetIndices.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Please look at the FPFHTest implementation for reference (in /trunk/features/include/pcl/features/feature_evaluation)</p>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul> 
      </ul>
    </div>
    <div class="footer">
    </div>
  </body>
</html>